<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brazil E-commerce WebXR Analytics</title>
    <style>
        /* --- GLOBAL RESET --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        body { overflow: hidden; background: #000; }
        #container { width: 100vw; height: 100vh; }

        /* --- MODERN GLASS INFO PANEL --- */
        #info-panel {
            position: absolute;
            top: 20px; left: 20px;
            width: 340px;
            background: rgba(10, 10, 10, 0.85); /* Dark Glass */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: #e0e0e0;
            padding: 0;
            z-index: 100;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* HEADER */
        .panel-header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel-header h2 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: #fff;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-header .live-indicator {
            width: 8px; height: 8px;
            background: #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff88;
            animation: blink 2s infinite;
        }

        /* ACCORDION (DROPDOWNS) */
        details {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: background 0.2s;
        }
        details:last-child { border-bottom: none; }
        details:hover { background: rgba(255, 255, 255, 0.02); }

        summary {
            padding: 12px 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ccc;
            outline: none;
        }
        summary::-webkit-details-marker { display: none; }
        summary::after {
            content: '+';
            font-size: 16px;
            font-weight: 300;
            transition: transform 0.3s;
        }
        details[open] summary::after { transform: rotate(45deg); }
        details[open] summary { color: #fff; background: rgba(255, 255, 255, 0.05); }

        /* CONTENT INSIDE DROPDOWNS */
        .content {
            padding: 12px 20px;
            font-size: 12px;
            line-height: 1.6;
            color: #aaa;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        .content p { margin-bottom: 8px; }
        .content p:last-child { margin-bottom: 0; }
        
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .dot { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }

        /* FOOTER */
        .panel-footer {
            padding: 10px 20px;
            font-size: 10px;
            text-align: center;
            color: #666;
            background: rgba(0,0,0,0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* ANIMATIONS */
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
        
        /* CONTROLS (BUTTONS) */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            padding: 10px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        button {
            padding: 10px 18px;
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        button:hover { background: rgba(255,255,255,0.1); color: #fff; transform: translateY(-2px); }
        
       /* ACTIVE STATES */
        #causal-button.active { background: rgba(255, 50, 50, 0.2); border-color: #ff3333; color: #ff3333; box-shadow: 0 0 15px rgba(255, 0, 0, 0.2); }
        #correlation-button.active { background: rgba(0, 204, 204, 0.2); border-color: #00ffff; color: #00ffff; box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); }
        #sentiment-button.active { background: rgba(204, 0, 204, 0.2); border-color: #ff00ff; color: #ff00ff; box-shadow: 0 0 15px rgba(255, 0, 255, 0.2); }
        #retention-button.active { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
        
        /* UPDATED: Optimization Active State (High-Vis Orange) */
        #optimize-button.active { 
            background: rgba(255, 255, 255, 0.2); 
            border-color: hsl(0, 0%, 100%); 
            color: #ffffff; /* This bright orange is very visible on black */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); 
            animation: pulse-orange 2s infinite; 
        }

        #vr-button { background: #1a73e8; border: none; color: white; }
        #vr-button:hover { background: #1557b0; }

    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info-panel">
        <div class="panel-header">
            <h2><div class="live-indicator"></div> Supply Chain AI</h2>
        </div>

        <div class="accordion">
            <details open>
                <summary>üìä Data Visualization</summary>
                <div class="content">
                    <p>Visualizing 200k+ shipments across Brazil.</p>
                    <div class="legend-item"><span class="dot" style="background:white;"></span> <strong>Bar Height:</strong> Delivery Delay</div>
                    <div class="legend-item"><span class="dot" style="background:#ff3333;"></span> <strong>Color (Red):</strong> Cancellation Risk</div>
                    <div class="legend-item"><span class="dot" style="background:grey;"></span> <strong>Width:</strong> Order Volume</div>
                </div>
            </details>

            <details>
                <summary style="color: #0088ff;">üí° AI Optimization</summary>
                <div class="content">
                    <p><strong>Interactive Mode:</strong></p>
                    <p>1. Activate <strong>OPTIMIZATION</strong> button below.</p>
                    <p>2. <strong>Click anywhere</strong> on the map floor.</p>
                    <p>3. AI uses K-Means to find the nearest demand cluster and calculates Days Saved vs. SP Hub.</p>
                </div>
            </details>

            <details>
                <summary style="color: #00ffff;">ü§ñ ML Insights</summary>
                <div class="content">
                    <p><strong>üîó Correlations (Arcs):</strong> Connects states with statistically identical failure patterns.</p>
                    <p><strong>üëÅÔ∏è Causal Inference:</strong> Red flows indicate regions where distance is the <em>proven cause</em> of delay.</p>
                </div>
            </details>

            <details>
                <summary style="color: #ffd700;">üíé Customer Retention</summary>
                <div class="content">
                    <p><strong>Orbiting Gems</strong> represent loyalty:</p>
                    <p>ü•á <strong>Gold (3):</strong> >80% Return Rate</p>
                    <p>ü•à <strong>Silver (2):</strong> >50% Return Rate</p>
                    <p>ü•â <strong>Bronze (1):</strong> <50% Return Rate</p>
                </div>
            </details>

            <details>
                <summary style="color: #ff00ff;">üí¨Customer Sentiment</summary>
                <div class="content">
                    <p>Customer Rating Analysis</p>
                    <p>üòç = Positive Sentiment</p>
                    <p>ü§¨ = Negative Sentiment</p>
                </div>
            </details>
        </div>

        <div class="panel-footer">
            Drag to Rotate ‚Ä¢ Scroll to Zoom ‚Ä¢ Click Bars for Info
        </div>
    </div>
    
    <div class="controls">
        <button id="correlation-button">üîó Links</button>
        <button id="causal-button">üëÅÔ∏è Causal</button>
        <button id="sentiment-button">üí¨ NLP</button>
        <button id="retention-button">üíé Loyalty</button>
        <button id="optimize-button">üí° Optimization</button>
        <button id="vr-button">VR MODE</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. DATA SETUP ---
        const data = [
            { "region":"AC", "avg_delay_days":20.63, "late_orders_pct":0.037, "cancel_rate":0.0, "total_orders":81, "sentiment":0.52, "avg_delay_norm":1.78, "lat":-9.96, "lon":-67.83, "retention":0.098 },
            { "region":"AL", "avg_delay_days":24.02, "late_orders_pct":0.23, "cancel_rate":0.002, "total_orders":417, "sentiment":0.37, "avg_delay_norm":2.07, "lat":-9.63, "lon":-35.75, "retention":0.06 },
            { "region":"AM", "avg_delay_days":25.94, "late_orders_pct":0.04, "cancel_rate":0.0, "total_orders":149, "sentiment":0.59, "avg_delay_norm":2.23, "lat":-3.08, "lon":-60.01, "retention":0.054 },
            { "region":"AP", "avg_delay_days":26.73, "late_orders_pct":0.044, "cancel_rate":0.0, "total_orders":68, "sentiment":0.59, "avg_delay_norm":2.30, "lat":0.03, "lon":-51.07, "retention":0.029 },
            { "region":"BA", "avg_delay_days":18.88, "late_orders_pct":0.135, "cancel_rate":0.004, "total_orders":3397, "sentiment":0.43, "avg_delay_norm":1.62, "lat":-12.95, "lon":-38.95, "retention":0.058 },
            { "region":"CE", "avg_delay_days":20.81, "late_orders_pct":0.147, "cancel_rate":0.005, "total_orders":1339, "sentiment":0.42, "avg_delay_norm":1.79, "lat":-3.78, "lon":-38.58, "retention":0.035 },
            { "region":"DF", "avg_delay_days":12.53, "late_orders_pct":0.068, "cancel_rate":0.003, "total_orders":2160, "sentiment":0.53, "avg_delay_norm":1.08, "lat":-15.81, "lon":-47.93, "retention":0.06 },
            { "region":"ES", "avg_delay_days":15.34, "late_orders_pct":0.119, "cancel_rate":0.004, "total_orders":2043, "sentiment":0.52, "avg_delay_norm":1.32, "lat":-20.29, "lon":-40.32, "retention":0.062 },
            { "region":"GO", "avg_delay_days":15.14, "late_orders_pct":0.079, "cancel_rate":0.006, "total_orders":2037, "sentiment":0.52, "avg_delay_norm":1.30, "lat":-16.68, "lon":-49.26, "retention":0.066 },
            { "region":"MA", "avg_delay_days":21.06, "late_orders_pct":0.187, "cancel_rate":0.005, "total_orders":751, "sentiment":0.38, "avg_delay_norm":1.81, "lat":-3.28, "lon":-44.29, "retention":0.052 },
            { "region":"MG", "avg_delay_days":11.54, "late_orders_pct":0.054, "cancel_rate":0.005, "total_orders":11706, "sentiment":0.56, "avg_delay_norm":0.99, "lat":-19.92, "lon":-43.97, "retention":0.062 },
            { "region":"MS", "avg_delay_days":15.20, "late_orders_pct":0.112, "cancel_rate":0.002, "total_orders":726, "sentiment":0.55, "avg_delay_norm":1.31, "lat":-20.48, "lon":-54.61, "retention":0.055 },
            { "region":"MT", "avg_delay_days":17.58, "late_orders_pct":0.065, "cancel_rate":0.002, "total_orders":910, "sentiment":0.55, "avg_delay_norm":1.51, "lat":-15.24, "lon":-56.03, "retention":0.068 },
            { "region":"PA", "avg_delay_days":23.31, "late_orders_pct":0.119, "cancel_rate":0.004, "total_orders":981, "sentiment":0.42, "avg_delay_norm":2.01, "lat":-1.46, "lon":-48.48, "retention":0.051 },
            { "region":"PB", "avg_delay_days":19.93, "late_orders_pct":0.106, "cancel_rate":0.003, "total_orders":537, "sentiment":0.50, "avg_delay_norm":1.71, "lat":-7.12, "lon":-35.48, "retention":0.059 },
            { "region":"PE", "avg_delay_days":17.93, "late_orders_pct":0.103, "cancel_rate":0.003, "total_orders":1663, "sentiment":0.50, "avg_delay_norm":1.54, "lat":-8.08, "lon":-34.95, "retention":0.05 },
            { "region":"PI", "avg_delay_days":18.98, "late_orders_pct":0.153, "cancel_rate":0.008, "total_orders":496, "sentiment":0.46, "avg_delay_norm":1.63, "lat":-5.09, "lon":-42.76, "retention":0.048 },
            { "region":"PR", "avg_delay_days":11.53, "late_orders_pct":0.048, "cancel_rate":0.004, "total_orders":5064, "sentiment":0.59, "avg_delay_norm":0.99, "lat":-25.38, "lon":-50.61, "retention":0.061 },
            { "region":"RJ", "avg_delay_days":14.85, "late_orders_pct":0.129, "cancel_rate":0.006, "total_orders":12930, "sentiment":0.43, "avg_delay_norm":1.28, "lat":-22.87, "lon":-43.24, "retention":0.069 },
            { "region":"RN", "avg_delay_days":18.81, "late_orders_pct":0.104, "cancel_rate":0.0, "total_orders":487, "sentiment":0.55, "avg_delay_norm":1.62, "lat":-5.83, "lon":-35.26, "retention":0.045 },
            { "region":"RO", "avg_delay_days":18.91, "late_orders_pct":0.027, "cancel_rate":0.011, "total_orders":253, "sentiment":0.52, "avg_delay_norm":1.63, "lat":-10.43, "lon":-63.02, "retention":0.094 },
            { "region":"RR", "avg_delay_days":28.97, "late_orders_pct":0.108, "cancel_rate":0.021, "total_orders":46, "sentiment":0.30, "avg_delay_norm":2.5, "lat":2.82, "lon":-60.69, "retention":0.043 },
            { "region":"RS", "avg_delay_days":14.83, "late_orders_pct":0.070, "cancel_rate":0.004, "total_orders":5506, "sentiment":0.56, "avg_delay_norm":1.28, "lat":-29.79, "lon":-51.24, "retention":0.065 },
            { "region":"SC", "avg_delay_days":14.50, "late_orders_pct":0.095, "cancel_rate":0.005, "total_orders":3651, "sentiment":0.53, "avg_delay_norm":1.25, "lat":-27.09, "lon":-49.03, "retention":0.056 },
            { "region":"SE", "avg_delay_days":21.02, "late_orders_pct":0.145, "cancel_rate":0.002, "total_orders":350, "sentiment":0.40, "avg_delay_norm":1.81, "lat":-10.92, "lon":-37.07, "retention":0.054 },
            { "region":"SP", "avg_delay_days":8.30, "late_orders_pct":0.057, "cancel_rate":0.007, "total_orders":41964, "sentiment":0.58, "avg_delay_norm":0.71, "lat":-23.52, "lon":-46.68, "retention":0.066 },
            { "region":"TO", "avg_delay_days":17.22, "late_orders_pct":0.125, "cancel_rate":0.003, "total_orders":280, "sentiment":0.54, "avg_delay_norm":1.48, "lat":-10.18, "lon":-48.32, "retention":0.05 }
        ];

        // Border coordinates
        const brazilBorder = [
            [-60.6758, 5.2721], [-59.9, 5.2], [-51.0694, 4.5], [-50.5, 2.5], [-50.0, 1.7],
            [-49.5, 1.2], [-44.5, -0.2], [-41.8, -2.9], [-38.5, -3.7], [-35.5, -5.5],
            [-34.8, -7.0], [-34.8, -8.5], [-35.0, -9.5], [-36.5, -10.5], [-37.5, -11.0],
            [-38.5, -12.5], [-39.0, -14.5], [-39.0, -17.0], [-39.8, -19.6], [-40.5, -20.3],
            [-41.0, -21.0], [-42.0, -22.0], [-43.2, -22.9], [-44.5, -23.3], [-45.8, -23.5],
            [-48.0, -24.0], [-48.5, -25.5], [-48.6, -26.5], [-48.7, -27.5], [-49.5, -29.0],
            [-50.0, -30.0], [-52.0, -32.0], [-53.4, -33.7], [-53.6, -33.75], [-53.4, -32.5],
            [-54.0, -31.5], [-55.0, -30.9], [-56.0, -30.1], [-57.6, -30.2], [-58.2, -27.4],
            [-58.2, -24.0], [-57.8, -22.1], [-57.6, -20.0], [-57.9, -19.0], [-58.2, -17.5],
            [-58.0, -16.0], [-57.7, -15.0], [-60.0, -13.5], [-61.0, -12.5], [-62.8, -11.0],
            [-64.8, -10.5], [-65.4, -9.7], [-67.3, -9.7], [-69.0, -9.5], [-70.1, -9.4],
            [-72.0, -9.4], [-73.0, -9.3], [-73.9, -8.5], [-73.9, -7.3], [-73.7, -6.0],
            [-73.1, -4.9], [-72.9, -3.3], [-72.0, -2.4], [-70.8, -1.2], [-70.0, -0.1],
            [-69.9, 0.9], [-69.3, 0.9], [-68.0, 1.7], [-66.8, 1.2], [-65.5, 1.1],
            [-64.0, 1.6], [-63.4, 2.0], [-61.4, 2.7], [-60.6758, 5.2721]
        ];

        const causalFindings = [
            { source: "SP", effect: "weekend", val: "0.1d", type: "info" },
            { source: "SP", effect: "high_order", val: "4.0d", type: "info" },
            { source: "RJ", effect: "hub", val: "-1.3d", type: "good" },
            { source: "RJ", effect: "weekend", val: "0.2d", type: "info" },
            { source: "MG", effect: "distance", val: "+2.5d", type: "bad" },
        ];
        
        const farStates = ['AM', 'RR', 'AP', 'AC', 'RO', 'PA', 'TO'];
        const neighborStates = ['MG', 'PR', 'RJ', 'ES', 'SC'];

        // GROUPS
        const causalGroup = new THREE.Group(); causalGroup.visible = false; 
        const correlationGroup = new THREE.Group(); correlationGroup.visible = false;
        const sentimentGroup = new THREE.Group(); sentimentGroup.visible = false;
        const retentionGroup = new THREE.Group(); retentionGroup.visible = false;
        
        // OPTIMIZATION GROUP
        const optimizationGroup = new THREE.Group(); 
        optimizationGroup.visible = false; 
        
        const flowParticles = []; 
        let optimizationParticles = []; // Using 'let' to avoid reassignment errors

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        // Add Optimization Group to Scene
        scene.add(optimizationGroup);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 12);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        const allLats = brazilBorder.map(p => p[1]);
        const allLons = brazilBorder.map(p => p[0]);
        const latRange = { min: Math.min(...allLats), max: Math.max(...allLats) };
        const lonRange = { min: Math.min(...allLons), max: Math.max(...allLons) };
        
        const normalize = (value, min, max, newMin, newMax) => {
            return ((value - min) / (max - min)) * (newMax - newMin) + newMin;
        };

        const floorGeometry = new THREE.PlaneGeometry(26, 26);
        const canvas = document.createElement('canvas');
        canvas.width = 2048; canvas.height = 2048;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#0d0d0d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const latToY = (lat) => normalize(lat, latRange.min, latRange.max, canvas.height - 100, 100);
        const lonToX = (lon) => normalize(lon, lonRange.min, lonRange.max, 100, canvas.width - 100);
        
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 6;
        ctx.fillStyle = '#0a3d2a';
        ctx.beginPath();
        brazilBorder.forEach((point, i) => {
            const x = lonToX(point[0]);
            const y = latToY(point[1]);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'Bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        data.forEach(region => {
            const x = lonToX(region.lon);
            const y = latToY(region.lat);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(x - 35, y - 20, 70, 40);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(region.region, x, y);
        });
        
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 128) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
        }
        
        const floorMaterial = new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas), side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const bars = [];
        const rings = [];
        const particles = [];
        const maxOrders = Math.max(...data.map(d => d.total_orders));
        const regionMap = {};

        data.forEach((region, idx) => {
            const x = normalize(region.lon, lonRange.min, lonRange.max, -11, 11);
            const z = -normalize(region.lat, latRange.min, latRange.max, -11, 11);
            const height = Math.max(0.2, region.avg_delay_norm * 1.5);
            regionMap[region.region] = { x, y: height, z };

            const cancelColor = new THREE.Color();
            cancelColor.setHSL(0.33 - (region.cancel_rate * 15), 0.8, 0.5);
            const size = 0.3 + (region.total_orders / maxOrders) * 1.5;
            
            const geometry = new THREE.BoxGeometry(size, height, size);
            const material = new THREE.MeshPhongMaterial({ color: cancelColor, emissive: cancelColor, emissiveIntensity: 0.2, transparent: true, opacity: 0.9 });
            const bar = new THREE.Mesh(geometry, material);
            bar.position.set(x, height / 2, z);
            bar.userData = { region, index: idx, size: size };
            scene.add(bar);
            bars.push(bar);

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(size * 0.8, size * 1.2, 32),
                new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: region.late_orders_pct * 2, side: THREE.DoubleSide })
            );
            ring.position.set(x, 0.05, z);
            ring.rotation.x = -Math.PI / 2;
            ring.userData = { baseOpacity: region.late_orders_pct * 2 };
            scene.add(ring);
            rings.push(ring);

            const particleCount = Math.floor((region.total_orders / maxOrders) * 50);
            const pGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = x + (Math.random() - 0.5) * size;
                positions[i * 3 + 1] = height + Math.random() * 2;
                positions[i * 3 + 2] = z + (Math.random() - 0.5) * size;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const pSys = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.6 }));
            pSys.userData = { baseY: height };
            scene.add(pSys);
            particles.push(pSys);

            const labelCanvas = document.createElement('canvas');
            const labelCtx = labelCanvas.getContext('2d');
            labelCanvas.width = 256; labelCanvas.height = 128;
            labelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            labelCtx.fillRect(0, 0, labelCanvas.width, labelCanvas.height);
            labelCtx.font = 'Bold 48px Arial';
            labelCtx.fillStyle = 'white';
            labelCtx.textAlign = 'center';
            labelCtx.fillText(region.region, 128, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(labelCanvas) }));
            sprite.position.set(x, height + 0.5, z);
            sprite.scale.set(1, 0.5, 1);
            scene.add(sprite);
        });

        // --- 1. UPDATED CURVED CORRELATION LINES ---
        const correlationMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        
        data.forEach((region1, i) => {
            data.forEach((region2, j) => {
                if (i >= j) return;
                
                const delayDiff = Math.abs(region1.avg_delay_norm - region2.avg_delay_norm);
                const cancelDiff = Math.abs(region1.cancel_rate - region2.cancel_rate);
                const lateDiff = Math.abs(region1.late_orders_pct - region2.late_orders_pct);
                const similarity = Math.sqrt(delayDiff**2 + cancelDiff**2 * 100 + lateDiff**2);
                
                // Strict threshold (0.2)
                if (similarity < 0.2) {
                    const p1 = regionMap[region1.region];
                    const p2 = regionMap[region2.region];
                    
                    const v1 = new THREE.Vector3(p1.x, 0.5, p1.z);
                    const v2 = new THREE.Vector3(p2.x, 0.5, p2.z);
                    
                    // Bezier Curve Logic
                    const dist = v1.distanceTo(v2);
                    const mid = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                    mid.y += dist * 0.4; // Arc Height
                    
                    const curve = new THREE.QuadraticBezierCurve3(v1, mid, v2);
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const line = new THREE.Line(geometry, correlationMat);
                    correlationGroup.add(line);
                }
            });
        });
        scene.add(correlationGroup);

        // 2. CAUSAL VISUALIZATION
        function createCausalIndicators(scene, regionMap) {
            scene.add(causalGroup);
            const groupedFindings = {};
            causalFindings.forEach(f => {
                if (!groupedFindings[f.source]) groupedFindings[f.source] = [];
                groupedFindings[f.source].push(f);
            });
            Object.keys(groupedFindings).forEach(regionKey => {
                const mapPos = regionMap[regionKey];
                const findings = groupedFindings[regionKey];
                if (!mapPos) return;
                let bubbleIndex = 0;
                findings.forEach(finding => {
                    let targetStates = [];
                    let arcColor = 0xffffff;
                    if (finding.effect === 'distance') { targetStates = farStates; arcColor = 0xff3333; } 
                    else if (finding.effect === 'hub') { targetStates = neighborStates; arcColor = 0x00ff88; }
                    if (targetStates.length > 0) {
                        targetStates.forEach(targetKey => {
                            if (targetKey === regionKey) return;
                            const targetPos = regionMap[targetKey];
                            if (!targetPos) return;
                            const p1 = new THREE.Vector3(mapPos.x, mapPos.y, mapPos.z);
                            const p2 = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z);
                            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                            mid.y += 3 + p1.distanceTo(p2) * 0.3;
                            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
                            const points = curve.getPoints(40);
                            const geo = new THREE.BufferGeometry().setFromPoints(points);
                            const mat = new THREE.LineBasicMaterial({ color: arcColor, transparent: true, opacity: 0.15 });
                            causalGroup.add(new THREE.Line(geo, mat));
                            
                            const flowCount = 10;
                            const flowGeo = new THREE.BufferGeometry();
                            const flowPos = new Float32Array(flowCount * 3);
                            const flowOffsets = []; 
                            for(let i=0; i<flowCount; i++) { flowOffsets.push(Math.random()); flowPos[i*3]=0; flowPos[i*3+1]=0; flowPos[i*3+2]=0; }
                            flowGeo.setAttribute('position', new THREE.BufferAttribute(flowPos, 3));
                            const flowSys = new THREE.Points(flowGeo, new THREE.PointsMaterial({ color: arcColor, size: 0.15, transparent: true, opacity: 0.8 }));
                            flowSys.userData = { curve: curve, offsets: flowOffsets, speed: 0.005 };
                            causalGroup.add(flowSys);
                            flowParticles.push(flowSys);
                        });
                    }
                    const yPos = mapPos.y + 1.2 + (bubbleIndex * 0.8);
                    const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128; const ctx = canvas.getContext('2d');
                    let bgColor = 'rgba(100, 100, 100, 0.8)'; let borderColor = '#cccccc';
                    if (finding.type === 'good') { bgColor = 'rgba(0, 100, 50, 0.8)'; borderColor = '#00ff88'; }
                    if (finding.type === 'bad') { bgColor = 'rgba(150, 0, 0, 0.8)'; borderColor = '#ff3333'; }
                    ctx.fillStyle = bgColor; ctx.strokeStyle = borderColor; ctx.lineWidth = 4;
                    if(ctx.roundRect) { ctx.beginPath(); ctx.roundRect(10, 10, 236, 108, 20); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(10,10,236,108); ctx.strokeRect(10,10,236,108); }
                    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.font = 'Bold 36px Arial'; ctx.fillText(finding.val, 128, 50); ctx.font = '24px Arial'; ctx.fillStyle = '#eeeeee'; ctx.fillText(finding.effect.toUpperCase(), 128, 90);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                    sprite.position.set(mapPos.x, yPos, mapPos.z); sprite.scale.set(1.5, 0.75, 1); sprite.userData = { baseY: yPos, offset: bubbleIndex * 100 + Math.random() * 100 };
                    causalGroup.add(sprite);
                    bubbleIndex++;
                });
            });
        }
        createCausalIndicators(scene, regionMap);

        // 3. SENTIMENT
        function createSentimentEmojis(scene, regionMap) {
            scene.add(sentimentGroup);
            data.forEach(region => {
                const mapPos = regionMap[region.region];
                if(!mapPos) return;
                let emoji = "üòê"; 
                if (region.sentiment >= 0.55) emoji = "üòç"; else if (region.sentiment <= 0.45) emoji = "ü§¨"; 
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d');
                ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.arc(128, 128, 100, 0, Math.PI*2); ctx.fill();
                ctx.font = "160px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(emoji, 128, 138);
                const texture = new THREE.CanvasTexture(canvas);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
                const startY = mapPos.y + 0.5; 
                sprite.position.set(mapPos.x, startY, mapPos.z + 0.6); sprite.scale.set(1.0, 1.0, 1); sprite.userData = { yPos: startY, offset: Math.random() * Math.PI };
                sentimentGroup.add(sprite);
            });
        }
        createSentimentEmojis(scene, regionMap);

        // 4. RETENTION
        function createRetentionOrbitals(scene, regionMap) {
            scene.add(retentionGroup);
            const geo = new THREE.OctahedronGeometry(0.12);
            const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2, emissive: 0x443300 });
            const matSilver = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2, emissive: 0x222222 });
            const matBronze = new THREE.MeshStandardMaterial({ color: 0xcd7f32, metalness: 0.6, roughness: 0.4, emissive: 0x221100 });
            data.forEach(region => {
                const mapPos = regionMap[region.region];
                const barSize = bars.find(b => b.userData.region.region === region.region).userData.size;
                const rate = region.retention;
                let count = 1; let mat = matBronze;
                if (rate > 0.06) { count = 3; mat = matGold; } else if (rate > 0.045) { count = 2; mat = matSilver; } 
                const radius = (barSize / 2) + 0.35;
                for(let i=0; i<count; i++) {
                    const gem = new THREE.Mesh(geo, mat);
                    gem.position.set(mapPos.x + radius, mapPos.y / 2, mapPos.z);
                    gem.userData = { center: {x: mapPos.x, z: mapPos.z}, radius: radius, angle: (i / count) * Math.PI * 2, speed: 0.02 + (rate * 0.5), y: (mapPos.y / 2) + (i * 0.1) };
                    retentionGroup.add(gem);
                }
            });
        }
        createRetentionOrbitals(scene, regionMap);

        // --- MATH HELPERS ---
        function deg2rad(deg) { return deg * (Math.PI / 180); }
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            const R = 6371; 
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // --- K-MEANS OPTIMIZATION LOGIC ---
        function updateOptimizationVisuals(targetPoint) {
            while(optimizationGroup.children.length > 0){ 
                const child = optimizationGroup.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                optimizationGroup.remove(child);
            }
            optimizationParticles = [];

            const distances = [];
            Object.keys(regionMap).forEach(key => {
                const rPos = regionMap[key];
                const dist = Math.sqrt( Math.pow(targetPoint.x - rPos.x, 2) + Math.pow(targetPoint.z - rPos.z, 2) );
                distances.push({ region: key, dist: dist, pos: rPos, weight: data.find(d => d.region === key).total_orders });
            });
            distances.sort((a, b) => a.dist - b.dist);
            const cluster = distances.slice(0, 5); 

            let sumX = 0, sumZ = 0, totalWeight = 0;
            cluster.forEach(node => {
                sumX += node.pos.x * node.weight;
                sumZ += node.pos.z * node.weight;
                totalWeight += node.weight;
            });
            const optimalX = sumX / totalWeight;
            const optimalZ = sumZ / totalWeight;
            const optimalPoint = new THREE.Vector3(optimalX, 0.6, optimalZ);

            const clickGeo = new THREE.SphereGeometry(0.3);
            const clickMat = new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 });
            const clickMarker = new THREE.Mesh(clickGeo, clickMat);
            clickMarker.position.copy(targetPoint);
            optimizationGroup.add(clickMarker);

            const snapGeo = new THREE.BufferGeometry().setFromPoints([targetPoint, optimalPoint]);
            const snapMat = new THREE.LineDashedMaterial({ color: 0xffff00, dashSize: 0.5, gapSize: 0.2 });
            const snapLine = new THREE.Line(snapGeo, snapMat);
            snapLine.computeLineDistances();
            optimizationGroup.add(snapLine);

            const whGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const whMat = new THREE.MeshPhongMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8, emissive: 0x004400 });
            const warehouse = new THREE.Mesh(whGeo, whMat);
            warehouse.position.copy(optimalPoint);
            optimizationGroup.add(warehouse);

            const spRegion = data.find(r => r.region === 'SP');
            const getLatLon = (vec3) => {
                const lon = ((vec3.x - (-11)) / (11 - (-11))) * (lonRange.max - lonRange.min) + lonRange.min;
                const lat = ((-vec3.z - (-11)) / (11 - (-11))) * (latRange.max - latRange.min) + latRange.min;
                return { lat, lon };
            }
            const newHubCoords = getLatLon(optimalPoint);
            let totalKmSaved = 0;

            cluster.forEach(node => {
                const regionData = data.find(d => d.region === node.region);
                const distFromHQ = getDistanceFromLatLonInKm(spRegion.lat, spRegion.lon, regionData.lat, regionData.lon);
                const distFromNewHub = getDistanceFromLatLonInKm(newHubCoords.lat, newHubCoords.lon, regionData.lat, regionData.lon);
                let delta = distFromHQ - distFromNewHub;
                if (delta > 0) totalKmSaved += delta;
                
                const p1 = new THREE.Vector3(optimalPoint.x, 0.6, optimalPoint.z);
                const p2 = new THREE.Vector3(node.pos.x, node.pos.y, node.pos.z);
                const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                mid.y += 4; 
                const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
                const points = curve.getPoints(40);
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 });
                optimizationGroup.add(new THREE.Line(lineGeo, lineMat));

                const flowCount = 10;
                const flowGeo = new THREE.BufferGeometry();
                const flowPos = new Float32Array(flowCount * 3);
                const flowOffsets = [];
                for(let i=0; i<flowCount; i++) { flowOffsets.push(Math.random()); flowPos[i*3]=0; flowPos[i*3+1]=0; flowPos[i*3+2]=0; }
                flowGeo.setAttribute('position', new THREE.BufferAttribute(flowPos, 3));
                const flowSys = new THREE.Points(flowGeo, new THREE.PointsMaterial({ color: 0xccffcc, size: 0.15 }));
                flowSys.userData = { curve: curve, offsets: flowOffsets, speed: 0.01 };
                optimizationGroup.add(flowSys);
                optimizationParticles.push(flowSys);
            });

            const avgDaysSaved = ((totalKmSaved / cluster.length) / 800).toFixed(1);

            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 100, 0, 0.9)'; 
            if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(10, 10, 492, 108, 20); ctx.fill(); } else { ctx.fillRect(10,10,492,108); }
            ctx.font = 'Bold 40px Arial'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`AI CENTER: ${cluster[0].region} Cluster`, 256, 45); 
            ctx.font = '30px Arial';
            ctx.fillText(`üéØ Optimization Correction | -${avgDaysSaved} Days`, 256, 90);
            
            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            label.position.copy(optimalPoint); label.position.y += 3; label.scale.set(4, 1, 1);
            optimizationGroup.add(label);
        }

        // --- BUTTON HANDLERS ---
        let isCausalMode = false;
        document.getElementById('causal-button').addEventListener('click', (e) => { isCausalMode = !isCausalMode; causalGroup.visible = isCausalMode; e.target.classList.toggle('active'); });

        let isCorrelationMode = false;
        document.getElementById('correlation-button').addEventListener('click', (e) => { isCorrelationMode = !isCorrelationMode; correlationGroup.visible = isCorrelationMode; e.target.classList.toggle('active'); });

        let isSentimentMode = false;
        document.getElementById('sentiment-button').addEventListener('click', (e) => { isSentimentMode = !isSentimentMode; sentimentGroup.visible = isSentimentMode; e.target.classList.toggle('active'); });

        let isRetentionMode = false;
        document.getElementById('retention-button').addEventListener('click', (e) => { isRetentionMode = !isRetentionMode; retentionGroup.visible = isRetentionMode; e.target.classList.toggle('active'); });

        let isOptimizationMode = false;
        document.getElementById('optimize-button').addEventListener('click', (e) => {
            isOptimizationMode = !isOptimizationMode;
            optimizationGroup.visible = isOptimizationMode;
            e.target.classList.toggle('active');
            if(isOptimizationMode) {
                e.target.style.background = "#0088ff"; e.target.style.borderColor = "#00ffff"; e.target.style.boxShadow = "0 0 15px rgba(0, 136, 255, 0.6)";
            } else {
                e.target.style.background = "#333"; e.target.style.borderColor = "#555"; e.target.style.boxShadow = "none";
                while(optimizationGroup.children.length > 0){ optimizationGroup.remove(optimizationGroup.children[0]); }
                optimizationParticles = [];
            }
        });

        // --- CONSOLIDATED MOUSE CONTROLS ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0.4, y: 0 };
        const cameraDistance = 18;
        const mouseRaycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedBar = null;

        const updateCamera = () => {
            if(!renderer.xr.isPresenting) {
                camera.position.x = Math.sin(cameraRotation.y) * cameraDistance * Math.cos(cameraRotation.x);
                camera.position.y = Math.sin(cameraRotation.x) * cameraDistance + 5;
                camera.position.z = Math.cos(cameraRotation.y) * cameraDistance * Math.cos(cameraRotation.x);
                camera.lookAt(0, 2, 0);
            }
        };
        updateCamera();

        window.addEventListener('mousedown', (e) => { 
            if (e.button === 0) { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; }
        });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        window.addEventListener('mousemove', (e) => {
            // Camera Rotation
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                cameraRotation.y += deltaX * 0.005;
                cameraRotation.x -= deltaY * 0.005;
                cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
                previousMousePosition = { x: e.clientX, y: e.clientY };
                updateCamera();
                return; 
            }
            // Hover logic
            if (renderer.xr.isPresenting) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            mouseRaycaster.setFromCamera(mouse, camera);
            bars.forEach(bar => { bar.material.emissiveIntensity = 0.2; bar.scale.set(1, 1, 1); });
            const intersects = mouseRaycaster.intersectObjects(bars);
            if (intersects.length > 0) {
                const bar = intersects[0].object;
                bar.material.emissiveIntensity = 0.5; bar.scale.set(1.1, 1, 1.1);
                selectedBar = bar;
            } else { selectedBar = null; }
        });

        // Smart Click Logic
        window.addEventListener('click', (e) => {
            if (isDragging || renderer.xr.isPresenting) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            mouseRaycaster.setFromCamera(mouse, camera);

            if (isOptimizationMode) {
                const floorIntersects = mouseRaycaster.intersectObject(floor);
                if (floorIntersects.length > 0) {
                    const point = floorIntersects[0].point;
                    updateOptimizationVisuals(point);
                }
            } else {
                const intersects = mouseRaycaster.intersectObjects(bars);
                if (intersects.length > 0) {
                    const data = intersects[0].object.userData.region;
                    alert(`Region: ${data.region}\nRetention: ${(data.retention*100).toFixed(0)}%\nSentiment: ${data.sentiment}\nAvg Delay: ${data.avg_delay_days.toFixed(2)} days`);
                }
            }
        });

        // --- VR ---
        const controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        scene.add(controller1);
        const controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        scene.add(controller2);
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -5)]);
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const line1 = new THREE.Line(laserGeometry, laserMaterial);
        line1.scale.z = 5;
        controller1.add(line1.clone());
        controller2.add(line1.clone());
        
        const vrInfoGroup = new THREE.Group(); scene.add(vrInfoGroup); vrInfoGroup.visible = false;
        function updateVRInfoPanel(data, position) {
            while(vrInfoGroup.children.length > 0){ vrInfoGroup.remove(vrInfoGroup.children[0]); }
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0, 0, 0, 0.9)"; ctx.strokeStyle = "#00ff88"; ctx.lineWidth = 5;
            if(ctx.roundRect) { ctx.beginPath(); ctx.roundRect(10, 10, 492, 236, 20); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(10,10,492,236); ctx.strokeRect(10,10,492,236); }
            ctx.fillStyle = "white"; ctx.font = "Bold 40px Arial"; ctx.fillText(`Region: ${data.region}`, 40, 60); ctx.font = "30px Arial"; ctx.fillText(`Avg Delay: ${data.avg_delay_days.toFixed(2)} days`, 40, 110);
            ctx.fillText(`Retention: ${(data.retention*100).toFixed(0)}%`, 40, 150); ctx.fillText(`Sentiment: ${data.sentiment}`, 40, 190);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(3, 1.5, 1); vrInfoGroup.add(sprite); vrInfoGroup.position.copy(position); vrInfoGroup.position.y += 2; vrInfoGroup.visible = true; vrInfoGroup.lookAt(camera.position); 
        }

        const vrRaycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();
        let intersectedBar = null;
        function onSelectStart(event) {
            if (intersectedBar) {
                const data = intersectedBar.userData.region;
                if (renderer.xr.isPresenting) updateVRInfoPanel(data, intersectedBar.position);
            }
        }
        function checkVRIntersections(controller) {
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            vrRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            vrRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            const intersects = vrRaycaster.intersectObjects(bars);
            if (intersects.length > 0) {
                if (intersectedBar != intersects[0].object) {
                    if (intersectedBar) intersectedBar.material.emissiveIntensity = 0.2;
                    intersectedBar = intersects[0].object; intersectedBar.material.emissiveIntensity = 1.0; 
                }
            } else { if (intersectedBar) intersectedBar.material.emissiveIntensity = 0.2; intersectedBar = null; }
        }

        document.getElementById('vr-button').addEventListener('click', async () => {
            if (navigator.xr && await navigator.xr.isSessionSupported('immersive-vr')) {
                const session = await navigator.xr.requestSession('immersive-vr');
                renderer.xr.setSession(session);
            } else { alert('VR not supported'); }
        });

        // Animation Loop
        let time = 0;
        const animate = () => {
            time += 0.016;
            if (renderer.xr.isPresenting) { checkVRIntersections(controller1); checkVRIntersections(controller2); }

            rings.forEach((ring, i) => { const pulse = Math.sin(time * 2 + i) * 0.5 + 0.5; ring.material.opacity = ring.userData.baseOpacity * pulse; ring.scale.set(1 + pulse * 0.2, 1 + pulse * 0.2, 1); });
            particles.forEach(p => {
                const pos = p.geometry.attributes.position.array;
                for (let i = 0; i < pos.length; i += 3) { pos[i + 1] += Math.sin(time + i) * 0.01; if (pos[i + 1] > p.userData.baseY + 3) pos[i + 1] = p.userData.baseY; }
                p.geometry.attributes.position.needsUpdate = true;
            });
            if (causalGroup.visible) {
                causalGroup.children.forEach(obj => { if (obj.isSprite && obj.userData.offset) { obj.position.y = obj.userData.baseY + Math.sin(time * 3 + obj.userData.offset) * 0.05; } });
                flowParticles.forEach(p => {
                    const positions = p.geometry.attributes.position.array; const curve = p.userData.curve; const offsets = p.userData.offsets; const speed = p.userData.speed;
                    for(let i = 0; i < offsets.length; i++) { offsets[i] += speed; if(offsets[i] > 1) offsets[i] = 0; const point = curve.getPoint(offsets[i]); positions[i*3] = point.x; positions[i*3+1] = point.y; positions[i*3+2] = point.z; }
                    p.geometry.attributes.position.needsUpdate = true;
                });
            }
            if (sentimentGroup.visible) { sentimentGroup.children.forEach((sprite) => { sprite.position.y = sprite.userData.yPos + Math.sin(time * 3 + sprite.userData.offset) * 0.1; }); }
            if (retentionGroup.visible) { retentionGroup.children.forEach(gem => { const ud = gem.userData; ud.angle += ud.speed; gem.position.x = ud.center.x + Math.cos(ud.angle) * ud.radius; gem.position.z = ud.center.z + Math.sin(ud.angle) * ud.radius; gem.rotation.y += 0.05; }); }
            
            if (optimizationGroup.visible) {
                optimizationParticles.forEach(p => {
                    const positions = p.geometry.attributes.position.array; const curve = p.userData.curve; const offsets = p.userData.offsets; const speed = p.userData.speed;
                    for(let i = 0; i < offsets.length; i++) { offsets[i] += speed; if(offsets[i] > 1) offsets[i] = 0; const point = curve.getPoint(offsets[i]); positions[i*3] = point.x; positions[i*3+1] = point.y; positions[i*3+2] = point.z; }
                    p.geometry.attributes.position.needsUpdate = true;
                });
            }
            renderer.render(scene, camera);
        };

        renderer.setAnimationLoop(animate);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
